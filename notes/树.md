# 树

## 树的基本概念
树是逻辑结构  

**树** 是n个结点的有限集合，n=0时称为空树  
非空树应满足  
1) 有且仅有一个特定的称为根的结点  
2) 当n>1时，其余结点可分为m(m>0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树

**n个结点的树中只有n-1条边**

### 基本术语  
祖先结点和子孙结点  
双亲结点和孩子结点  
兄弟结点  

**度**  
树中一个结点的子结点的个数称为该结点的度  
树中最大度数称为树的度  

**分支结点** 度大于0的结点  
**叶子结点** 度为0的结点  

**结点的层次** 根结点在第一层，以此类推  
**结点的高度** 自底向上的层次  
**结点的深度** 和层次一样  
**树的高度/深度 是树中结点的最大层数**  

**有序树** 从左到右每一个子树是有次序的  
**无序树** 与有序树想反  

**路径** 树中两个**结点**之间经过结点序列构成路径，路径是自上而下的，从双亲结点指向孩子结点  
**路径长度** 路径上所经历边的个数  

**森林** m (m>0)棵互不相交的树的集合  

### 树的性质

**1) 树中的结点树等于所有结点的度加1**  
**2) 度为m的树中第i层上至多有m^(i-1)个结点(i>=1)**  
**3) 高度为h的m叉树至多有(m^h - 1)/(m-1)个结点**  
**4) 具有n个结点的m叉树的最小高度为logm(n(m-1)+!) (取上界)**

## 二叉树
二叉树是n(n>=0)个结点的有限集合  
1) n=0时, 二叉树为空;
2) n>0时, 由根节点和两个互不相交的被称为根的左子树和右子树组成. 左子树和右子树也分别是一颗二叉树  

**五种基本形态**  
空树  
只有一个根节点  
只有左子树  
只有右子树  
有左子树也有右子树  

**二叉树和度为2的有序树的区别**  
1) 二叉树可以为空, 而度为2的有序树至少有三个结点  
2) 二叉树的孩子结点始终有左右之分, 而度为2有序树的孩子结点次序时相对的


### 满二叉树
一棵高度而h, 且含有2^h-1个结点的二叉树称为满二叉树 (最多结点的情况)

(个人感觉这里有点像二进制,满二叉树的第n层个数就是二进制的第n个bit)

对于编号为i的结点, 若存在, 其双亲的编号为(i/2 取下界), 左孩子为2i, 右孩子为2i+1  

### 完全二叉树
设一个高度为h, 有n个结点的二叉树, 当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时, 称为满二叉树

**性质**  
1) 若i<=(n/2), 则结点i为分支结点, 否则为叶子结点  
2) 叶子结点只可能在层次最大的两层上出现, 对于最大层的叶子结点, 都依次排在最左边的位置上.  
3) 度为1的结点若存在, 则只可能有一个, 且是编号最大的分支结点, 并孩子结点一定是左结点

### 二叉排序树
一棵二叉树, 若树非空则具有如下性质:  
对于任意结点若存在左子树或右子树, 则其左子树上所有结点的关键字均小于该结点, 右子树上所有结点的关键字均大于该结点.  
e.g.  
```
       8  
      / \
     4   16
    / \  / \
   2  5 10
  /\   \
 1  3   7
```


### 平衡二叉树  
树上任意结点的左子树和右子树的深度之差不超过1  

### 二叉树的性质
1)结点个数  
以结点本身来算: n = n0 + n1 + n2  即, 结点总数 = 度为0的结点总数 +  度为1的结点总数 + 度为2的结点总数  
以孩子结点来算: n = 0*n0 + 1*n1 + 2*n2 + 1  即, 结点总数 = 度为0的结点的孩子总数 + 度为1的结点的孩子总数 + 度为2的结点的孩子的总数 + 根节点  
可以推出 n0 = n2 + 1

2) 非空二叉树上第k层至多有2^(k-1)个结点 (k>=1) (同二进制)  
3) 高度为h的二叉树至多有2^h-1个结点  
4) 完全二叉树按从上到下, 从左到右的顺序依次编号1,2,...,n则有以下关系:  
当i>1时, 结点i的双亲结点标号为(i/2 取下界), 即当i为偶数时, 其双亲结点的编号为i/2, 他是双亲结点的左孩子; 当i为奇数时, 其双亲结点的编号为(i-1)/2, 他是双亲结点的右孩子  
当2i<=n时, 结点i的左孩子编号为2i, 否则无左孩子  
当2i+1<=n时, 结点i的右孩子编号为2i+1, 否则无右孩子  

5) 结点i所在层次为 log2(i)+1取下界 (完全二叉树)
6) 具有n个结点的完全二叉树的高度为log2(n)+1取下界 或log2(n+1)取上界

### 二叉树的顺序存储
用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素  
```
      1
     / \
    2   3
   / \ / \
  4  5 6
```
对于完全二叉树，有：  
结点i若存在左孩子，则左孩子编号为2i，若存在右孩子则右孩子编号为2i+1  

对应的数组存储结构就有了  
| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|   | 1 | 2 | 3 | 4 | 5 | 6 |

对于不是完全二叉树的，可以用0填充空的结点，当然这会浪费很多存储空间  

### 二叉树的链式存储  
用链表来存放二叉树

```
//结点
typedef struct BitNode{
    ElemType data;
    struct BitNode *lchild, *rchild;
}BitNode, *BitTree;



```
**含有n个结点的二叉链表中，有2n - (n-1) => n+1个空链域**  

### 二叉树的遍历  
an某条搜素路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次  

**1)先序遍历 O(n)**  
若二叉树非空  
a.访问根结点  
b.先序遍历左子树  
c.先序遍历右子树  
```
//递归先序
void PreOrder(BitTree T)
{
    if(NULL != T)
    {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

```

**2)中序遍历 O(n)**  
若二叉树非空  
a.中序遍历左子树  
b.访问根结点   
c.中序遍历右子树  
```
//递归中序
void InOrder(BitTree T)
{
    if(NULL != T)
    {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//非递归中序 借助栈
//1)初始时依次扫描根结点的所有左侧结点并将他们一一进栈  
//2)出栈一个结点，访问它  
//3)扫描该结点的右孩子结点并将其进栈  
//4)依次扫描右孩子结点的所有左侧结点并一一进栈
//5)重复2) - 4)直到栈空
void InOrder(BitTree T)
{
    Stack S;
    InitStack(S);
    BitNode *p = T;
    while(p || !isEmptyStack(S))
    {
        if(p)
        {
            push(S, p);
            p = p->lchild;  
        }
        else
        {
            p = pop(S);
            visit(p);
            p = p->rchild;
        }
    }
    while(!isStackEmpty(S))
    {

    }

    
}
```

**3)后序遍历 O(n)**  
若二叉树非空  
a.后序遍历左子树  
b.后序遍历右子树   
c.访问根结点  
```
//递归中序
void PostOrder(BitTree T)
{
    if(NULL != T)
    {
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
```

**4)层次遍历**  
借助队列  
a.初始将根入队并访问根结点  
b.若有左子树，则将左子树的根入队  
c.若有右子树，则将右子树的根入队  
d.然后出队，访问该结点
e.重复b - d 知道队空
```
void levelOrder(BitTree T)
{
    Queue Q;
    InitQueue(Q);
    BitNode *p = T;
    
    EnQueue(Q, p);
    while(!isEmpty(Q))
    {
        DeQueue(Q, p);
        visit(p);
        if(p->lchild);
            EnQueue(Q, p->lchild);
        if(p->rchild)
            EnQueue(Q, p->rchild);
    }
}
```

**由遍历序列构造二叉树**
由先序/后序遍历序列和中序遍历序列可以确定一棵二叉树  

在先序遍历序列中，第一个结点时根结点  
在中序遍历序列中，根结点的左边是左子树右边是右子树  